# 高性能MySQL

## 读写锁
- 读锁（共享锁）：读锁相互不阻塞。
	+ 在SQL Server中，默认情况下，数据被读取后，立即释放共享锁。
		- 例如，执行查询语句`SELECT * FROM my_table`时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。 例如，语句`SELECT * FROM my_table HOLDLOCK`就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。
- 写锁（排它锁）：阻塞其它的写锁和读锁。（写锁比读锁有更高的优先级，因此写锁可能被插入到读锁队列的前面）
	+ 产生排他锁的SQL语句如下：`select * from ad_plan for update`;

## 锁粒度
- 一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分的数据，而不是所有的资源。
- 但是，加锁也需要消耗资源，锁的获得，检查，释放等各种操作都会增加系统的开销。
	如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。
- 所谓锁的策略，就是在锁的开销和数据的安全性之间寻求平衡。

## 表锁、行级锁
- 表锁（table lock）: `mysql`中最基本的锁策略，并且是开销最小的策略。
- 行级锁（row lock）: 最大程度地支持并发处理（同时也带来了最大的锁开销）。
- 举个例子，一个用户表user，有主键id和用户生日birthday。
	+ 当你使用`update … where id=?`这样的语句时，数据库明确知道会影响哪一行，它就会使用行锁；
	+ 当你使用`update … where birthday=?`这样的的语句时，因为事先不知道会影响哪些行就可能会使用表锁。

## 事物
- 事物就是一组原子性的`SQL`查询，或者说一个独立的工作单元。事物内的语句，要么全部执行成功，要么全部执行失败。
- `ACID`表示原子性、一致性、隔离性、持久性
	+ 原子性(atomicity): 一个事物必须被视为一个不可分割的最小单元，整个事物中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事物来说，不能只执行其中的一部分操作，这就是事物的原子性。
	+ 一致性(consistency): 数据库总是从一个一致性的状态转换到另外一个一致性的状态。即使事物过程中系统崩溃，因为事物最终没有提交，所以事物中所作的修改也不会保存到数据库中。
	+ 隔离性(isolation): 通常来说
	+ 持久性(durability):
