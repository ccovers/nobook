# 高性能MySQL

## 读写锁
- 读锁（共享锁）：读锁相互不阻塞。
	+ 在`SQL Server`中，默认情况下，数据被读取后，立即释放共享锁。
		- 例如，执行查询语句`SELECT * FROM my_table`时，首先锁定第一页，读取之后，释放对第一页的锁定，然后锁定第二页。这样，就允许在读操作过程中，修改未被锁定的第一页。 例如，语句`SELECT * FROM my_table HOLDLOCK`就要求在整个查询过程中，保持对表的锁定，直到查询完成才释放锁定。
- 写锁（排它锁）：阻塞其它的写锁和读锁。（写锁比读锁有更高的优先级，因此写锁可能被插入到读锁队列的前面）
	+ 产生排他锁的SQL语句如下：`select * from ad_plan for update`;

## 锁粒度
- 一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分的数据，而不是所有的资源。
- 但是，加锁也需要消耗资源，锁的获得，检查，释放等各种操作都会增加系统的开销。
	如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。
- 所谓锁的策略，就是在锁的开销和数据的安全性之间寻求平衡。

## 表锁、行级锁
- 表锁（table lock）: `mysql`中最基本的锁策略，并且是开销最小的策略。
- 行级锁（row lock）: 最大程度地支持并发处理（同时也带来了最大的锁开销）。
- 举个例子，一个用户表user，有主键id和用户生日birthday。
	+ 当你使用`update … where id=?`这样的语句时，数据库明确知道会影响哪一行，它就会使用行锁；
	+ 当你使用`update … where birthday=?`这样的的语句时，因为事先不知道会影响哪些行就可能会使用表锁。

### 行级锁
- 悲观锁（写锁）:  `FOR UPDATE`
- 乐观锁（读锁）: `LOCK IN SHARE MODE`

- `Record Lock`: 单行记录上的锁
- `Gap Lock`: 间隙锁，锁定一个范围，但不包含记录本身
- `Next-KEY Lock`: `Gap Lock` + `Record Lock`，锁定一个范围并且锁定记录本身

- 锁是针对索引加锁，如果查询条件无索引，全表扫描、全表锁。
- 索引而非唯一索引时，查询单条记录，则锁定范围包含记录本身及记录两边的间隙。如果此时数据无记录，锁定范围(-∞,+∞)，即全表锁。
- `Innodb`对于行的查询都是采用`Next-KEY Lock`，但是当查询索引时含有唯一索引，`Innodb`会对`Next-KEY Lock`进行优化，降级为`Record Lock`，仅锁住索引本身而非范围。

## 事务
- 事务就是一组原子性的`SQL`查询，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。
- `ACID`表示原子性、一致性、隔离性、持久性
	+ 原子性(atomicity): 一个事务必须被视为一个不可分割的最小单元，整个事务中的所有操作要么全部提交成功，
		要么全部失败回滚，对于一个事务来说，不能只执行其中的一部分操作，这就是事务的原子性。
	+ 一致性(consistency): 数据库总是从一个一致性的状态转换到另外一个一致性的状态。即使事务过程中系统崩溃，
		因为事务最终没有提交，所以事务中所作的修改也不会保存到数据库中。
	+ 隔离性(isolation): 通常来说，一个事务所做的修改在最终提交以前，对其它事务是不可见的。
	+ 持久性(durability): 一旦事务提交，则其所做的修改会永久保存到数据库中。此时即使系统崩溃，
		修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多级别。有些持久性策略能提供非常强的安全保障，有些则未必。而且不可能做到100%的持久性保证的策略（如果数据库本身就能做到真正的持久性，那么备份又怎么能增加持久性呢？）。

## 隔离级别
1. `READ UNCOMMITED`(未提交读): 在`READ UNCOMMITED`级别，事务中的修改，即使没有提交，对其它事务也是可见的。
	事务可以读取未提交的数据，这也被成为脏读(Dirty Read)。这个级别会导致很多问题，从性能上来说，`READ UNCOMMITED`不会比其它级别好太多，但却缺乏其它级别的很多好处，除非真的有必要的理由，在实际应用中一般很少使用。
2. `READ COMMITED`(提交读): 大多数数据库的默认隔离级别都是`READ COMMITED`(但`MYSQL`不是)，
	`READ COMMITED`满足隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。换句话说，一个事务从开始到提交之前，所做的任何修改对其它事务是不可见的。这个级别有时候也叫做不可重复读(nonrepeatable read)，因为两次执行同样的查询，可能会得到不一样的结果。
3. `REPEATABLE READ`(可重复读): `REPEATABLE READ`解决了脏读的问题。
	该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但理论上，可重复读隔离级别还是无法解决另外一个幻读问题(Phantom Read)的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行(Phantom Row)。InNoDB和XtraDB存储引擎通过多版本并发控制(MVCC, Multiversion Concurrency Control)解决了幻读的问题。
4. `SERIALIZABLE`(可串行化): `SERIALIZABLE`是最高的隔离级别。它通过强制事务串行执行，避免了幻读的问题。
	简单来说，`SERIALIZABLE`会在读取的每一行的数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

## 死锁
- 死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
	当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时也会产生死锁。
- 死锁检测和死锁超时机制，InNoDB目前的处理死锁的方法是，将持有最少行级排它锁的事务进行回滚。
- 锁的行为和顺序和存储引擎相关，死锁产生的原因：有些事因为真正的数据冲突，但有些则完全是由于存储引擎的实现方式导致的。

## 多版本并发控制
- `InnoDB`的`MVCC`，是通过在每行记录后面保存两个隐藏的列来实现的。
	这两个列，一个保存了行的创建时间，一个保存了行的过期时间(或删除时间)。当然，存储的并不是实际时间值，而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动递增。`REPEATABLE READ`隔离级别下，`MVCC`是如何操作的:
	+ `SELECT`: `InnoDB`会根据以下两个条件检查每行记录，只有符合这两个条件的记录，才能返回作为查询结果。
		- `a`: `InnoDB`只查找版本早于当前事务版本的数据行(也就是，行的系统版本号小于或等于事务的系统版本号)
			，这样就可以确保事务读取的行，要么是在事务开始前已经存在，要么是事务自身插入或修改过的。
		- `b`: 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取道德行，从事务开始之前未被删除。
	+ `INSERT`: `InnoDB`为新插入的每一行保存当前系统版本号作为行版本号。
	+ `DELETE`: `InnoDB`为删除的每一行保存当前系统版本号作为行版本号。
	+ `UPDATE`: `InnoDB`为插入一行新记录，保存当前系统版本号作为行版本号，
		同时保存当前系统版本号到原来的行作为删除标识。

- 保存这两个额外系统版本号，使大多数读操作可以不用加锁。这样的设计使得读数据操作简单，性能更好，
	并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的检查工作，以及一些额外的维护工作。
- `MVCC`只在`REPEATABLE READ`和`READ COMMITED`两个隔离级别下工作。其他两个隔离级别都和`MVCC`不兼容，
	因为`READ UNCOMITTED`总是读取最新的数据行，而不是符合当前事务版本的数据行。而`SERIALIZABLE`则会对所有读取的行都加锁。
- `InnoDB`采用`MVCC`来支持高并发，并且实现了四个标准的隔离级别。其默认级别是`REPEATABLE READ`(可重复读)，
	并且通过间隙锁(next-key locking)策略防止幻读的出现。间隙锁使得`InnoDB`不仅仅锁定查询的行，还会对索引中间的间隙进行锁定，以防止幻影行的插入。


## 疑问（多版本并发控制`MVCC`，在可重复读的隔离级别下，读数据是否加读锁，若不加读锁，当较早的事务在较晚事务查询后更新并提交，那较晚事务再次查询时，仅靠多版本并发能控制可重复读？）
多版本并发控制：每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间(或删除时间)。当然，存储的并不是实际时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。

- 按时间顺序执行两个事务：
create_ver： 模拟创建版本号
delete_ver： 模拟删除版本号
```
table
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| id  | name  | create_ver  | delete_ver  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 1   | 小红	  | 1	 	    | 0			  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
1. 事务一开启， 分配系统版本号（25）：SELECT * FROM table WHERE id=1;
2. 事务二开启， 分配系统版本号（26）：SELECT * FROM table WHERE id=1;
3. 事务一：UPDATE table SET name='小明' WHERE id=1;
```
table
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| id  | name  | create_ver  | delete_ver  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 1   | 小红	  | 1	 	    | 25		  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| 1   | 小明	  | 25 			| 0			  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
4. 事务一：COMMIT;
5. 事务二：SELECT * FROM table WHERE id=1;
	- 隔离级别提交读时不用加读锁
	- 隔离级别可重复读时若不加读锁，则此时查出的结果要和第一次一致，但是仅靠`MVCC`无法达成效果？
6. 事务二：COMMIT;

我看有的地方说 Mysql InNoDB引擎使用多版本并发控制，读一般不加锁。但是在隔离级别为可重复读的情况下，当较早的事务在较晚事务查询后更新并提交，那较晚事务再次查询时，只靠MVCC会查出不一样的数据，是我理解有误还是说要加读锁呀？



答案：
	每个事务在启动的时候会扫描当时正在活跃(未提交)的事务集合 `trx_ids`，将来读取出来多行的时候，不仅会过滤掉 `tx_id` 比它自己大的行，还会过滤掉这个集合里面的行，这样来保证可重复读。
